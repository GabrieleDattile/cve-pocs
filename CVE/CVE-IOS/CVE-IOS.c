#include <stdio.h>
#include <mach/mach.h>

mach_port_t nuovo_port = MACH_PORT_NULL;

void ottieni_nuovo_port() {
    task_dyld_info_data_t info_task_dyld;
    mach_msg_type_number_t count = TASK_DYLD_INFO_COUNT;
    if (task_info(mach_task_self(), TASK_DYLD_INFO, (task_info_t)&info_task_dyld, &count) != KERN_SUCCESS) {
        printf("Impossibile ottenere le informazioni sul task\n");
        return;
    }
    uint64_t indirizzo_tutte_immagini_info = info_task_dyld.all_image_info_addr;
    while (indirizzo_tutte_immagini_info != 0) {
        struct mach_header_64 intestazione;
        mach_vm_size_t dimensione = 0;
        if (mach_vm_read_overwrite(mach_task_self(), indirizzo_tutte_immagini_info, sizeof(intestazione), (mach_vm_address_t)&intestazione, &dimensione) != KERN_SUCCESS || dimensione != sizeof(intestazione)) {
            printf("Impossibile leggere l'intestazione mach\n");
            return;
        }
        if (intestazione.magic != MH_MAGIC_64) {
            printf("Numero magico dell'intestazione mach non valido\n");
            return;
        }
        if (intestazione.filetype != MH_EXECUTE) {
            indirizzo_tutte_immagini_info = intestazione.nextcmd;
            continue;
        }
        if (intestazione.ncmds == 0 || intestazione.cmdsize == 0) {
            printf("Conteggio o dimensione dei comandi di caricamento non validi\n");
            return;
        }
        uint64_t indirizzo_comando = indirizzo_tutte_immagini_info + sizeof(intestazione);
        for (uint32_t i = 0; i < intestazione.ncmds; i++) {
            struct load_command comando;
            if (mach_vm_read_overwrite(mach_task_self(), indirizzo_comando, sizeof(comando), (mach_vm_address_t)&comando, &dimensione) != KERN_SUCCESS || dimensione != sizeof(comando)) {
                printf("Impossibile leggere il comando di caricamento\n");
                return;
            }
            if (comando.cmd == LC_SEGMENT_64) {
                struct segment_command_64 comando_segmento;
                if (mach_vm_read_overwrite(mach_task_self(), indirizzo_comando, sizeof(comando_segmento), (mach_vm_address_t)&comando_segmento, &dimensione) != KERN_SUCCESS || dimensione != sizeof(comando_segmento)) {
                    printf("Impossibile leggere il comando del segmento\n");
                    return;
                }
                if (strcmp(comando_segmento.segname, "__TEXT_EXEC") == 0) {
                    nuovo_port = comando_segmento.vmaddr;
                    printf("Otteniuto nuovo_port: 0x%llx\n", nuovo_port);
                    return;
                }
            }
            indirizzo_comando += comando.cmdsize;
        }
        indirizzo_tutte_immagini_info = intestazione.nextcmd;
    }
    printf("Impossibile ottenere nuovo_port\n");
}

int main(int argc, const char * argv[]) {
    ottieni_nuovo_port();
    return 0;
}
